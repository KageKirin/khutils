// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_DATAMULTIMAP_ KHUTILS_DATA_MULTIMAP_H_
#define FLATBUFFERS_GENERATED_DATAMULTIMAP_ KHUTILS_DATA_MULTIMAP_H_

#include "flatbuffers/flatbuffers.h"

namespace khutils
{
	namespace data_multimap
	{

		struct Data;

		struct MapEntry;

		struct Map;

		/// container for random data
		struct Data FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
		{
			enum
			{
				VT_DATA = 4
			};
			const flatbuffers::Vector<uint8_t>* data() const
			{
				return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_DATA);
			}
			bool Verify(flatbuffers::Verifier& verifier) const
			{
				return VerifyTableStart(verifier) && VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA)
					   && verifier.Verify(data()) && verifier.EndTable();
			}
		};

		struct DataBuilder
		{
			flatbuffers::FlatBufferBuilder& fbb_;
			flatbuffers::uoffset_t			start_;
			void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data)
			{
				fbb_.AddOffset(Data::VT_DATA, data);
			}
			DataBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
			{
				start_ = fbb_.StartTable();
			}
			DataBuilder&			  operator=(const DataBuilder&);
			flatbuffers::Offset<Data> Finish()
			{
				auto o = flatbuffers::Offset<Data>(fbb_.EndTable(start_, 1));
				return o;
			}
		};

		inline flatbuffers::Offset<Data> CreateData(flatbuffers::FlatBufferBuilder&					  _fbb,
													flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0)
		{
			DataBuilder builder_(_fbb);
			builder_.add_data(data);
			return builder_.Finish();
		}

		/// simple simili-multimap type for Flatbuffers
		/// maps a key to a number of values
		/// key: string
		/// values: array of Data
		struct MapEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
		{
			enum
			{
				VT_KEY	= 4,
				VT_VALUES = 6
			};
			const flatbuffers::String* key() const
			{
				return GetPointer<const flatbuffers::String*>(VT_KEY);
			}
			bool KeyCompareLessThan(const MapEntry* o) const
			{
				return *key() < *o->key();
			}
			int KeyCompareWithValue(const char* val) const
			{
				return strcmp(key()->c_str(), val);
			}
			const flatbuffers::Vector<flatbuffers::Offset<Data>>* values() const
			{
				return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Data>>*>(VT_VALUES);
			}
			bool Verify(flatbuffers::Verifier& verifier) const
			{
				return VerifyTableStart(verifier) && VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_KEY)
					   && verifier.Verify(key()) && VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUES)
					   && verifier.Verify(values()) && verifier.VerifyVectorOfTables(values()) && verifier.EndTable();
			}
		};

		struct MapEntryBuilder
		{
			flatbuffers::FlatBufferBuilder& fbb_;
			flatbuffers::uoffset_t			start_;
			void add_key(flatbuffers::Offset<flatbuffers::String> key)
			{
				fbb_.AddOffset(MapEntry::VT_KEY, key);
			}
			void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Data>>> values)
			{
				fbb_.AddOffset(MapEntry::VT_VALUES, values);
			}
			MapEntryBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
			{
				start_ = fbb_.StartTable();
			}
			MapEntryBuilder&			  operator=(const MapEntryBuilder&);
			flatbuffers::Offset<MapEntry> Finish()
			{
				auto o = flatbuffers::Offset<MapEntry>(fbb_.EndTable(start_, 2));
				fbb_.Required(o, MapEntry::VT_KEY);	// key
				return o;
			}
		};

		inline flatbuffers::Offset<MapEntry> CreateMapEntry(flatbuffers::FlatBufferBuilder&			 _fbb,
															flatbuffers::Offset<flatbuffers::String> key = 0,
															flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Data>>> values = 0)
		{
			MapEntryBuilder builder_(_fbb);
			builder_.add_values(values);
			builder_.add_key(key);
			return builder_.Finish();
		}

		/// container for multimap entries
		struct Map FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
		{
			enum
			{
				VT_ENTRIES = 4
			};
			const flatbuffers::Vector<flatbuffers::Offset<MapEntry>>* entries() const
			{
				return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MapEntry>>*>(VT_ENTRIES);
			}
			bool Verify(flatbuffers::Verifier& verifier) const
			{
				return VerifyTableStart(verifier) && VerifyField<flatbuffers::uoffset_t>(verifier, VT_ENTRIES)
					   && verifier.Verify(entries()) && verifier.VerifyVectorOfTables(entries()) && verifier.EndTable();
			}
		};

		struct MapBuilder
		{
			flatbuffers::FlatBufferBuilder& fbb_;
			flatbuffers::uoffset_t			start_;
			void add_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapEntry>>> entries)
			{
				fbb_.AddOffset(Map::VT_ENTRIES, entries);
			}
			MapBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
			{
				start_ = fbb_.StartTable();
			}
			MapBuilder&				 operator=(const MapBuilder&);
			flatbuffers::Offset<Map> Finish()
			{
				auto o = flatbuffers::Offset<Map>(fbb_.EndTable(start_, 1));
				return o;
			}
		};

		inline flatbuffers::Offset<Map> CreateMap(flatbuffers::FlatBufferBuilder& _fbb,
												  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapEntry>>> entries = 0)
		{
			MapBuilder builder_(_fbb);
			builder_.add_entries(entries);
			return builder_.Finish();
		}

	}	// namespace data_multimap
}	// namespace khutils

#endif	// FLATBUFFERS_GENERATED_DATAMULTIMAP_ KHUTILS_DATA_MULTIMAP_H_
